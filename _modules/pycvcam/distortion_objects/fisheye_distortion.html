
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pycvcam.distortion_objects.fisheye_distortion &#8212; pycvcam 1.5.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=e0a75244"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pycvcam/distortion_objects/fisheye_distortion';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">pycvcam 1.5.0 documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../installation.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../usage.html">
    Usage
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../installation.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../usage.html">
    Usage
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">pycvcam.distortion_objects.fisheye_distortion</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pycvcam.distortion_objects.fisheye_distortion</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2025 Artezaru</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">Integral</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cv2</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..core</span><span class="w"> </span><span class="kn">import</span> <span class="n">Distortion</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..core.package</span><span class="w"> </span><span class="kn">import</span> <span class="n">Package</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">optimize_input_points</span>

<div class="viewcode-block" id="FisheyeDistortion">
<a class="viewcode-back" href="../../../api_doc/fisheye_distortion.html#pycvcam.FisheyeDistortion">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FisheyeDistortion</span><span class="p">(</span><span class="n">Distortion</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Subclass of the :class:`pycvcam.core.Distortion` class that represents the fisheye distortion model.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This class represents the distortion transformation, which is the middle step of the process from the ``world_points`` to the ``image_points``.</span>

<span class="sd">    The ``FisheyeDistortion`` model in the using a polynomial model on the angle :math:`\theta` between the optical axis and the incoming ray.</span>

<span class="sd">    Lets consider ``normalized_points`` in the camera normalized coordinate system :math:`\vec{x}_n = (x_n, y_n)`, the corresponding ``distorted_points`` in the camera normalized coordinate system are given :math:`\vec{x}_d` can be obtained by :</span>

<span class="sd">    .. math::</span>

<span class="sd">        \vec{x}_d = \text{distort}(\vec{x}_n, \lambda_1, \lambda_2, \lambda_3, \ldots)</span>

<span class="sd">    The model of distortion is given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \begin{bmatrix}</span>
<span class="sd">        x_d \\</span>
<span class="sd">        y_d</span>
<span class="sd">        \end{bmatrix}</span>
<span class="sd">        =</span>
<span class="sd">        \begin{bmatrix}</span>
<span class="sd">        x(r, \theta_d) \\</span>
<span class="sd">        y(r, \theta_d)</span>
<span class="sd">        \end{bmatrix}</span>

<span class="sd">    where :math:`r^2 = x_n^2 + y_n^2` and :math:`\theta_d` is the distorted angle given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \theta_d = \theta(1 + d_1\theta^2 + d_2\theta^4 + d_3\theta^6 + \ldots)</span>

<span class="sd">    The number of parameters is variable and depends on the number of distortion coefficients :math:`d_i` used in the model.</span>

<span class="sd">    .. note::</span>

<span class="sd">        If the number of parameters is ``Nparams``, the maximum order of the polynomial is :math:`2*Nparams + 1`. and only odd powers of :math:`\theta` are used in the polynomial.</span>
<span class="sd">    </span>
<span class="sd">    .. warning::</span>

<span class="sd">        If the number of parameters ``Nparams`` is given during instantiation, the given parameters are truncated or extended to the given number of parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parameters : Optional[numpy.ndarray], optional</span>
<span class="sd">        The parameters of the distortion transformation. It should be a numpy array of shape (Nparams,) containing the distortion coefficients ordered as described above. Default is None, which means no distortion is setted.</span>

<span class="sd">    Nparams : Optional[Integral], optional</span>
<span class="sd">        The number of parameters for the distortion model. If not specified, it will be inferred from the shape of the `parameters` array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create an distortion object with a specific number of parameters:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import numpy</span>
<span class="sd">        from pycvcam import FisheyeDistortion</span>

<span class="sd">        parameters = numpy.array([0.1, 0.01, 0.02, 0.03, 0.001])</span>

<span class="sd">        distortion = FisheyeDistortion(parameters=parameters)</span>

<span class="sd">    Then you can use the distortion object to transform ``normalized_points`` to ``distorted_points``:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        normalized_points = numpy.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]]) # shape (Npoints, 2)</span>

<span class="sd">        result = distortion.transform(normalized_points)</span>
<span class="sd">        distorted_points = result.distorted_points # Shape (Npoints, 2)</span>
<span class="sd">        print(distorted_points)</span>

<span class="sd">    You can also access to the jacobian of the distortion transformation:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        result = distortion.transform(normalized_points, dx=True, dp=True)</span>
<span class="sd">        distorted_points_dx = result.jacobian_dx  # Shape (Npoints, 2, 2)</span>
<span class="sd">        distorted_points_dp = result.jacobian_dp  # Shape (Npoints, 2, Nparams = 5)</span>
<span class="sd">        print(distorted_points_dx) </span>
<span class="sd">        print(distorted_points_dp)</span>

<span class="sd">    The inverse transformation can be computed using the `inverse_transform` method:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        inverse_result = distortion.inverse_transform(distorted_points, dx=True, dp=True)</span>
<span class="sd">        normalized_points = inverse_result.normalized_points  # Shape (Npoints, 2)</span>
<span class="sd">        print(normalized_points)</span>

<span class="sd">    .. note::</span>

<span class="sd">        The jacobian with respect to the depth is not computed.</span>
<span class="sd">    </span>
<span class="sd">    .. seealso::</span>

<span class="sd">        For more information about the transformation process, see:</span>

<span class="sd">        - :meth:`pycvcam.FisheyeDistortion._transform` to transform the ``normalized_points`` to ``distorted_points``.</span>
<span class="sd">        - :meth:`pycvcam.FisheyeDistortion._inverse_transform` to transform the ``distorted_points`` back to ``normalized_points``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Nparams</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Integral</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Initialize the Transform base class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Nparams</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span> <span class="o">=</span> <span class="n">Nparams</span>

    <span class="c1"># =============================================</span>
    <span class="c1"># Overwrite some properties from the base class</span>
    <span class="c1"># =============================================</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get or set the parameters of the distortion model.</span>

<span class="sd">        If None, no distortion is applied.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the number of parameters is ``Nparams``, the maximum order of the polynomial is :math:`2*Nparams + 1`. and only odd powers of :math:`\theta` are used in the polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters : numpy.ndarray, optional</span>
<span class="sd">            The parameters of the distortion model. If None, no distortion is applied. The default is None.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the parameters is not a 1D numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span>

    <span class="nd">@parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">parameters</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The parameters should be a 1D numpy array.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">parameters</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Always returns None for the FisheyeDistortion class, as it does not have any constants.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="nd">@constants</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;FisheyeDistortion model has no constants, must be set to None.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constants</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Nparams</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get or set the number of parameters of the distortion model.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the number of parameters is ``Nparams``, the maximum order of the polynomial is :math:`2*Nparams + 1`. and only odd powers of :math:`\theta` are used in the polynomial.</span>

<span class="sd">        If the given number of parameters is less than the current number of parameters, the parameters are truncated.</span>
<span class="sd">        If the given number of parameters is greater than the current number of parameters, the parameters are extended with zeros.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of parameters of the distortion model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">size</span>
        
    <span class="nd">@Nparams</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Nparams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Integral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The number of parameters should be an integer.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of parameters should be a non-negative integer.&quot;</span><span class="p">)</span>
        
        <span class="c1"># If parameters is None, create a new array of zeros</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="c1"># Update the number of parameters instead of creating a new array</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[:</span><span class="n">value</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parameter_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the names of the parameters of the distortion transformation : [&quot;d_1&quot;, &quot;d_2&quot;, &quot;d_3&quot;, &quot;d_4&quot;, ...]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[str]</span>
<span class="sd">            The names of the parameters of the distortion transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;d_</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">params</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">constant_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Always returns an empty list for the FisheyeDistortion class, as it does not have any constants.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

<div class="viewcode-block" id="FisheyeDistortion.is_set">
<a class="viewcode-back" href="../../../api_doc/fisheye_distortion.html#pycvcam.FisheyeDistortion.is_set">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the distortion parameters are set (always True for FisheyeDistortion).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the distortion parameters are set, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span></div>


    
    <span class="c1"># =================================================================</span>
    <span class="c1"># Distortion Model Coefficients</span>
    <span class="c1"># =================================================================</span>
<div class="viewcode-block" id="FisheyeDistortion.set_di">
<a class="viewcode-back" href="../../../api_doc/fisheye_distortion.html#pycvcam.FisheyeDistortion.set_di">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_di</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Number</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the coefficient for the i-th power of the polynomial decomposition.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \theta_d = \theta(1 + d_1\theta^2 + d_2\theta^4 + d_3\theta^6 + \ldots)</span>

<span class="sd">        For i=3 set the coefficient :math:`d_3` associated to the :math:`\theta^7 = 2 * i + 1` term.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            The index of the distortion coefficient.</span>
<span class="sd">        value : float</span>
<span class="sd">            The value of the distortion coefficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The index of the distortion coefficient should be an integer.&quot;</span><span class="p">)</span>
        <span class="n">i_min</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">i_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i_min</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">i_max</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The index of the distortion coefficient should be between </span><span class="si">{</span><span class="n">i_min</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">i_max</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="FisheyeDistortion.get_di">
<a class="viewcode-back" href="../../../api_doc/fisheye_distortion.html#pycvcam.FisheyeDistortion.get_di">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_di</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Integral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Number</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the coefficient for the i-th power of the polynomial decomposition.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \theta_d = \theta(1 + d_1\theta^2 + d_2\theta^4 + d_3\theta^6 + \ldots)</span>

<span class="sd">        For i=3 return the coefficient :math:`d_3` associated to the :math:`\theta^7 = 2 * i + 1` term.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            The index of the distortion coefficient.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the distortion coefficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The index of the distortion coefficient should be an integer.&quot;</span><span class="p">)</span>
        <span class="n">i_min</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">i_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i_min</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">i_max</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The index of the distortion coefficient should be between </span><span class="si">{</span><span class="n">i_min</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">i_max</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="FisheyeDistortion.make_empty">
<a class="viewcode-back" href="../../../api_doc/fisheye_distortion.html#pycvcam.FisheyeDistortion.make_empty">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set to zero the parameters of the distortion model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="p">,</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span></div>


    <span class="c1"># =================================================================</span>
    <span class="c1"># Internal methods to compute the distortion</span>
    <span class="c1"># =================================================================</span>
<div class="viewcode-block" id="FisheyeDistortion._cartesian_to_polar">
<a class="viewcode-back" href="../../../api_doc/fisheye_distortion.html#pycvcam.FisheyeDistortion._cartesian_to_polar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_cartesian_to_polar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cartesian</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert cartesian coordinates to polar coordinates.</span>
<span class="sd">        </span>
<span class="sd">        The input ``cartesian`` points are given in the form :math:`(x, y)` with shape (Npoints, 2).</span>
<span class="sd">        The output ``polar`` points are given in the form :math:`(r, \theta)` with shape (Npoints, 2), where :math:`r = \sqrt{x^2 + y^2}` and :math:`\theta = \arctan2(y, x)`.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \begin{bmatrix}</span>
<span class="sd">            r \\</span>
<span class="sd">            \theta \\</span>
<span class="sd">            \end{bmatrix}</span>
<span class="sd">            =</span>
<span class="sd">            \begin{bmatrix}</span>
<span class="sd">            \sqrt{x^2 + y^2} \\</span>
<span class="sd">            \arctan2(y, x) \\</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">        The jacobian with respect to the cartesian points is an array with shape (Npoints, 2, 2).</span>

<span class="sd">        .. math::</span>

<span class="sd">            J = \begin{bmatrix}</span>
<span class="sd">            \frac{\partial r}{\partial x} &amp; \frac{\partial r}{\partial y} \\</span>
<span class="sd">            \frac{\partial \theta}{\partial x} &amp; \frac{\partial \theta}{\partial y} \\</span>
<span class="sd">            \end{bmatrix}</span>
<span class="sd">            =</span>
<span class="sd">            \begin{bmatrix}</span>
<span class="sd">            \frac{x}{\sqrt{x^2 + y^2}} &amp; \frac{y}{\sqrt{x^2 + y^2}} \\</span>
<span class="sd">            -\frac{y}{x^2 + y^2} &amp; \frac{x}{x^2 + y^2} \\</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This method is not intended to be used directly, but rather through the :meth:`pycvcam.core.Transform.transform` method.</span>
<span class="sd">            Please ensure, the shape of the input ``cartesian`` is (Npoints, 2) before calling this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cartesian : numpy.ndarray</span>
<span class="sd">            The cartesian points to be converted. Shape (Npoints, 2).</span>
<span class="sd">        </span>
<span class="sd">        dx : bool, optional</span>
<span class="sd">            If True, the jacobian with respect to the cartesian points is computed. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        polar : numpy.ndarray</span>
<span class="sd">            The polar points. Shape (Npoints, 2).</span>
<span class="sd">        </span>
<span class="sd">        jacobian_dx : Optional[numpy.ndarray]</span>
<span class="sd">            The jacobian of the polar points with respect to the cartesian points. Shape (Npoints, 2, 2) if dx is True, otherwise None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The dx parameter must be a boolean.&quot;</span><span class="p">)</span>

        <span class="c1"># Extract the cartesian coordinates</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">cartesian</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># shape (Npoints,)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">cartesian</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># shape (Npoints,)</span>
        
        <span class="c1"># Compute the polar coordinates</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># shape (Npoints,)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># shape (Npoints,)</span>

        <span class="n">polar</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">cartesian</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span> <span class="c1"># shape (Npoints, 2)</span>
        <span class="n">polar</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="n">polar</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span>

        <span class="c1"># Compute the jacobian with respect to the cartesian points</span>
        <span class="n">jacobian_dx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">dx</span><span class="p">:</span>
            <span class="n">jacobian_dx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">cartesian</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span> <span class="c1"># shape (Npoints, 2, 2)</span>
            <span class="n">r_safe</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="c1"># Avoid division by zero</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">r_safe</span> <span class="o">**</span> <span class="mi">2</span> <span class="c1"># shape (Npoints,)</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">r_safe</span> <span class="c1"># dr/dx</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">r_safe</span> <span class="c1"># dr/dy</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">y</span> <span class="o">/</span> <span class="n">r2</span> <span class="c1"># dtheta/dx</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">r2</span> <span class="c1"># dtheta/dy</span>

        <span class="k">return</span> <span class="n">polar</span><span class="p">,</span> <span class="n">jacobian_dx</span></div>

    

<div class="viewcode-block" id="FisheyeDistortion._polar_to_cartesian">
<a class="viewcode-back" href="../../../api_doc/fisheye_distortion.html#pycvcam.FisheyeDistortion._polar_to_cartesian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_polar_to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polar</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert polar coordinates to cartesian coordinates.</span>
<span class="sd">        </span>
<span class="sd">        The input ``polar`` points are given in the form :math:`(r, \theta)` with shape (Npoints, 2), where :math:`r = \sqrt{x^2 + y^2}` and :math:`\theta = \arctan2(y, x)`.</span>
<span class="sd">        The output ``cartesian`` points are given in the form :math:`(x, y)` with shape (Npoints, 2).</span>

<span class="sd">        .. math::</span>

<span class="sd">            \begin{bmatrix}</span>
<span class="sd">            x \\</span>
<span class="sd">            y \\</span>
<span class="sd">            \end{bmatrix}</span>
<span class="sd">            =</span>
<span class="sd">            \begin{bmatrix}</span>
<span class="sd">            r \cos(\theta) \\</span>
<span class="sd">            r \sin(\theta) \\</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">        The jacobian with respect to the polar points is an array with shape (Npoints, 2, 2).</span>

<span class="sd">        .. math::</span>

<span class="sd">            J = \begin{bmatrix}</span>
<span class="sd">            \frac{\partial x}{\partial r} &amp; \frac{\partial x}{\partial \theta} \\</span>
<span class="sd">            \frac{\partial y}{\partial r} &amp; \frac{\partial y}{\partial \theta} \\</span>
<span class="sd">            \end{bmatrix}</span>
<span class="sd">            =</span>
<span class="sd">            \begin{bmatrix}</span>
<span class="sd">            \cos(\theta) &amp; -r\sin(\theta) \\</span>
<span class="sd">            \sin(\theta) &amp; r\cos(\theta) \\</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This method is not intended to be used directly, but rather through the :meth:`pycvcam.core.Transform.transform` method.</span>
<span class="sd">            Please ensure, the shape of the input ``polar`` is (Npoints, 2) before calling this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        polar : numpy.ndarray</span>
<span class="sd">            The polar points to be converted. Shape (Npoints, 2).</span>
<span class="sd">        </span>
<span class="sd">        dx : bool, optional</span>
<span class="sd">            If True, the jacobian with respect to the polar points is computed. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cartesian : numpy.ndarray</span>
<span class="sd">            The cartesian points. Shape (Npoints, 2).</span>
<span class="sd">        </span>
<span class="sd">        jacobian_dx : Optional[numpy.ndarray]</span>
<span class="sd">            The jacobian of the cartesian points with respect to the polar points. Shape (Npoints, 2, 2) if dx is True, otherwise None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The dx parameter must be a boolean.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Extract the polar coordinates</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">polar</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># shape (Npoints,)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">polar</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># shape (Npoints,)</span>

        <span class="c1"># Compute the cartesian coordinates</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1"># shape (Npoints,)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1"># shape (Npoints,)</span>

        <span class="n">cartesian</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">polar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span> <span class="c1"># shape (Npoints, 2)</span>
        <span class="n">cartesian</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">cartesian</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

        <span class="c1"># Compute the jacobian with respect to the polar points</span>
        <span class="n">jacobian_dx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">dx</span><span class="p">:</span>
            <span class="n">jacobian_dx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">polar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span> <span class="c1"># shape (Npoints, 2, 2)</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1"># dx/dr</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">r</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1"># dx/dtheta</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1"># dy/dr</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1"># dy/dtheta</span>

        <span class="k">return</span> <span class="n">cartesian</span><span class="p">,</span> <span class="n">jacobian_dx</span></div>



    <span class="c1"># =================================================================</span>
    <span class="c1"># Implementation of the transform method</span>
    <span class="c1"># =================================================================</span>
<div class="viewcode-block" id="FisheyeDistortion._transform">
<a class="viewcode-back" href="../../../api_doc/fisheye_distortion.html#pycvcam.FisheyeDistortion._transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalized_points</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the transformation from the ``normalized_points`` to the ``distorted_points``.</span>

<span class="sd">        Lets consider ``normalized_points`` in the camera normalized coordinate system :math:`\vec{x}_n = (x_n, y_n)`, the corresponding ``distorted_points`` in the camera normalized coordinate system are given :math:`\vec{x}_d` can be obtained by :</span>

<span class="sd">        .. math::</span>

<span class="sd">            \vec{x}_d = \text{distort}(\vec{x}_n, \lambda_1, \lambda_2, \lambda_3, \ldots)</span>

<span class="sd">        The model of distortion is given by:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \begin{bmatrix}</span>
<span class="sd">            x_d \\</span>
<span class="sd">            y_d</span>
<span class="sd">            \end{bmatrix}</span>
<span class="sd">            =</span>
<span class="sd">            \begin{bmatrix}</span>
<span class="sd">            x(r, \theta_d) \\</span>
<span class="sd">            y(r, \theta_d)</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">        where :math:`r^2 = x_n^2 + y_n^2` and :math:`\theta_d` is the distorted angle given by:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \theta_d = \theta(1 + d_1\theta^2 + d_2\theta^4 + d_3\theta^6 + \ldots)</span>

<span class="sd">        The jacobians with respect to the distortion parameters is an array with shape (Npoints, 2, Nparams), where the last dimension represents the parameters in the order of the class attributes (d1, d2, d3, ...).</span>
<span class="sd">        The jacobian with respect to the normalized points is an array with shape (Npoints, 2, 2).</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This method is not intended to be used directly, but rather through the :meth:`pycvcam.core.Transform.transform` method.</span>
<span class="sd">            Please ensure, the shape of the input ``normalized_points`` is (Npoints, 2) before calling this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalized_points : numpy.ndarray</span>
<span class="sd">            The normalized points in camera normalized coordinates to be transformed. Shape (Npoints, 2).</span>

<span class="sd">        dx : bool, optional</span>
<span class="sd">            If True, the jacobian with respect to the normalized points is computed. Default is False</span>

<span class="sd">        dp : bool, optional</span>
<span class="sd">            If True, the jacobian with respect to the distortion parameters is computed. Default is False</span>

<span class="sd">        opencv : bool, optional</span>
<span class="sd">            If True, the distortion transformation is achieved using the OpenCV function ``projectPoints``.</span>
<span class="sd">            If False, the distortion transformation is achieved using the internal method.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        distorted_points : numpy.ndarray</span>
<span class="sd">            The distorted points in camera normalized coordinates. Shape (Npoints, 2).</span>

<span class="sd">        jacobian_dx : Optional[numpy.ndarray]</span>
<span class="sd">            The jacobian of the distorted points with respect to the normalized points. Shape (Npoints, 2, 2) if dx is True, otherwise None.</span>

<span class="sd">        jacobian_dp : Optional[numpy.ndarray]</span>
<span class="sd">            The jacobian of the distorted points with respect to the distortion parameters. Shape (Npoints, 2, Nparams) if dp is True, otherwise None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prepare the inputs data for distortion</span>
        <span class="n">x_N</span> <span class="o">=</span> <span class="n">normalized_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># shape (Npoints,)</span>
        <span class="n">y_N</span> <span class="o">=</span> <span class="n">normalized_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># shape (Npoints,)</span>
        <span class="n">Npoints</span> <span class="o">=</span> <span class="n">normalized_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Nparams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span>

        <span class="c1"># Convert to polar coordinates</span>
        <span class="n">polar</span><span class="p">,</span> <span class="n">jacobian_dx_cart2pol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cartesian_to_polar</span><span class="p">(</span><span class="n">normalized_points</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">)</span> <span class="c1"># shape (Npoints, 2), (Npoints, 2, 2) or None</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">polar</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># shape (Npoints,)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">polar</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># shape (Npoints,)</span>

        <span class="c1"># Apply the distortion model</span>
        <span class="n">theta_powers</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nparams</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># shape (Npoints, Nparams) # theta^2, theta^4, theta^6, ...</span>
        <span class="n">theta_d</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">theta_powers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">))</span> <span class="c1"># shape (Npoints,)</span>

        <span class="k">if</span> <span class="n">dx</span><span class="p">:</span>
            <span class="n">theta_d_dx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Npoints</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span> <span class="c1"># shape (Npoints, 1, 2)</span>
            <span class="c1"># dtheta_d/dtheta = 1 + 3 * d1 * theta^2 + 5 * d2 * theta^4 + 7 * d3 * theta^6 + ...</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nparams</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span> <span class="c1"># shape (Nparams,)</span>
            <span class="n">dtheta_d_dtheta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">theta_powers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">*</span> <span class="n">coefficients</span><span class="p">)</span> <span class="c1"># shape (Npoints,)</span>
            <span class="n">theta_d_dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dtheta_d_dtheta</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">jacobian_dx_cart2pol</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="c1"># shape (Npoints, 2)</span>
    
        <span class="k">if</span> <span class="n">dp</span> <span class="ow">and</span> <span class="n">Nparams</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">theta_d_dp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Npoints</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nparams</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span> <span class="c1"># shape (Npoints, 1, Nparams)</span>
            <span class="n">theta_d_dp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">theta_powers</span> <span class="c1"># shape (Npoints, Nparams)</span>
        
        <span class="c1"># Convert back to cartesian coordinates</span>
        <span class="n">distorted_points</span><span class="p">,</span> <span class="n">jacobian_dx_pol2cart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polar_to_cartesian</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">theta_d</span><span class="p">)),</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">)</span> <span class="c1"># shape (Npoints, 2), (Npoints, 2, 2) or None</span>

        <span class="c1"># Compute the jacobians</span>
        <span class="n">jacobian_dx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">dx</span><span class="p">:</span>
            <span class="n">jacobian_dx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Npoints</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span> <span class="c1"># shape (Npoints, 2, 2)</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">jacobian_dx_pol2cart</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">jacobian_dx_cart2pol</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">jacobian_dx_pol2cart</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">theta_d_dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># dx/dx_N</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">jacobian_dx_pol2cart</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">jacobian_dx_cart2pol</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">jacobian_dx_pol2cart</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">theta_d_dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># dx/dy_N</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">jacobian_dx_pol2cart</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">jacobian_dx_cart2pol</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">jacobian_dx_pol2cart</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">theta_d_dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># dy/dx_N</span>
            <span class="n">jacobian_dx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">jacobian_dx_pol2cart</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">jacobian_dx_cart2pol</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">jacobian_dx_pol2cart</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">theta_d_dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># dy/dy_N</span>

        <span class="n">jacobian_dp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">dp</span> <span class="ow">and</span> <span class="n">Nparams</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">jacobian_dp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Npoints</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Nparams</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span> <span class="c1"># shape (Npoints, 2, Nparams)</span>
            <span class="n">jacobian_dp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">jacobian_dx_pol2cart</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">][:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">theta_d_dp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="c1"># dx/dp</span>
            <span class="n">jacobian_dp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">jacobian_dx_pol2cart</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">][:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">theta_d_dp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="c1"># dy/dp</span>
        
        <span class="k">if</span> <span class="n">dp</span> <span class="ow">and</span> <span class="n">Nparams</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">jacobian_dp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Npoints</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Package</span><span class="o">.</span><span class="n">get_float_dtype</span><span class="p">())</span> <span class="c1"># shape (Npoints, 2, 0)</span>
        
        <span class="k">return</span> <span class="n">distorted_points</span><span class="p">,</span> <span class="n">jacobian_dx</span><span class="p">,</span> <span class="n">jacobian_dp</span></div>

    
<div class="viewcode-block" id="FisheyeDistortion._inverse_transform">
<a class="viewcode-back" href="../../../api_doc/fisheye_distortion.html#pycvcam.FisheyeDistortion._inverse_transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distorted_points</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the inverse transformation from the ``distorted_points`` to the ``normalized_points``.</span>

<span class="sd">        Lets consider ``distorted_points`` in the camera normalized coordinate system :math:`\vec{x}_d = (x_d, y_d)`, the corresponding ``normalized_points`` in the camera normalized coordinate system are obtained by an ``iterative`` algorithm that finds the points :math:`\vec{x}_n`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            - :func:`pycvcam.optimize.optimize_input_points` for the implementation of the iterative algorithm to find the inverse distortion points.</span>

<span class="sd">        The initial guess is setted to :math:`\vec{x}_{n} = \vec{x}_{d} - U(\vec{x}_{d})``, where :math:`U(\vec{x}_{d})` is the distortion field applied to the distorted points.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This method is not intended to be used directly, but rather through the :meth:`pycvcam.core.Transform.transform` method.</span>
<span class="sd">            Please ensure, the shape of the input ``image_points`` is (Npoints, 2) before calling this method.</span>

<span class="sd">            The jacobians with respect to the distortion parameters and the distorted points are always None, since it is an iterative algorithm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        distorted_points : numpy.ndarray</span>
<span class="sd">            The distorted points in camera normalized coordinates to be transformed. Shape (Npoints, 2).</span>

<span class="sd">        dx : bool, optional</span>
<span class="sd">            If True, the jacobian with respect to the distorted points is computed. Default is False</span>

<span class="sd">        dp : bool, optional</span>
<span class="sd">            If True, the jacobian with respect to the distortion parameters is computed. Default is False</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments to pass to the iterative algorithm. Not used in this implementation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        normalized_points : numpy.ndarray</span>
<span class="sd">            The normalized points in camera normalized coordinates, which are equal to the x and y components of the image points. Shape (Npoints, 2).</span>

<span class="sd">        jacobian_dx : Optional[numpy.ndarray]</span>
<span class="sd">            Always None, since the jacobian with respect to the distorted points is not computed by an iterative algorithm.</span>

<span class="sd">        jacobian_dp : Optional[numpy.ndarray]</span>
<span class="sd">            Always None, since the jacobian with respect to the distortion parameters is not computed by an iterative algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dx</span> <span class="ow">or</span> <span class="n">dp</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[WARNING]: Undistortion with dx=True or dp=True. The jacobians cannot be computed with this method. They are always None.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">normalized_points</span> <span class="o">=</span> <span class="n">optimize_input_points</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">distorted_points</span><span class="p">,</span>
            <span class="n">guess</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">distorted_points</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">distorted_points</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">_skip</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># Skip the checks on the input points</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">normalized_points</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025-2025, Artezaru.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>